#!/bin/bash
# run-e2e.sh - Comprehensive integration test script for weft-operator Helm chart.
#
# This script creates a Kind cluster, installs the weft-operator Helm chart,
# and verifies end-to-end functionality including:
# - CRD availability (WeftServer, WeftTunnel, WeftGateway, Gateway API)
# - WeftServer reconciliation (Internal creates Deployment/Service/PVC)
# - WeftTunnel reconciliation (creates Deployments per target server)
# - Status condition updates
# - Cleanup via owner references
# - Gateway API integration
#
# Prerequisites: Docker, Kind, Helm, kubectl, Bazel
#
# Usage: ./scripts/run-e2e.sh [--keep-cluster] [--skip-build]
#   --keep-cluster: Don't delete the Kind cluster on exit (useful for debugging)
#   --skip-build: Skip Docker image build (use existing image)

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "${SCRIPT_DIR}/.." && pwd)"
CLUSTER_NAME="weft-operator-e2e"
NAMESPACE="default"
RELEASE_NAME="weft-operator"
IMAGE_NAME="ghcr.io/aquaduct-dev/weft-operator"
IMAGE_TAG="e2e-test"
KEEP_CLUSTER=false
SKIP_BUILD=false

# Parse arguments
for arg in "$@"; do
    case $arg in
        --keep-cluster)
            KEEP_CLUSTER=true
            shift
            ;;
        --skip-build)
            SKIP_BUILD=true
            shift
            ;;
    esac
done

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

log_info() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

log_warn() {
    echo -e "${YELLOW}[WARN]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

log_test() {
    echo -e "${BLUE}[TEST]${NC} $1"
}

# Cleanup function
cleanup() {
    local exit_code=$?
    if [ "$KEEP_CLUSTER" = false ]; then
        log_info "Cleaning up Kind cluster..."
        kind delete cluster --name "$CLUSTER_NAME" 2>/dev/null || true
    else
        log_warn "Keeping cluster '$CLUSTER_NAME' for debugging"
        log_info "To delete later: kind delete cluster --name $CLUSTER_NAME"
        log_info "To access: kubectl config use-context kind-$CLUSTER_NAME"
    fi
    exit $exit_code
}

trap cleanup EXIT

# Check prerequisites
check_prerequisites() {
    log_info "Checking prerequisites..."
    
    local missing=()
    
    command -v docker >/dev/null 2>&1 || missing+=("docker")
    command -v kind >/dev/null 2>&1 || missing+=("kind")
    command -v helm >/dev/null 2>&1 || missing+=("helm")
    command -v kubectl >/dev/null 2>&1 || missing+=("kubectl")
    command -v bazelisk >/dev/null 2>&1 || command -v bazel >/dev/null 2>&1 || missing+=("bazel/bazelisk")
    
    if [ ${#missing[@]} -ne 0 ]; then
        log_error "Missing required tools: ${missing[*]}"
        log_error "Please install them before running this script."
        exit 1
    fi
    
    # Check Docker is running
    if ! docker info >/dev/null 2>&1; then
        log_error "Docker daemon is not running"
        exit 1
    fi
    
    log_info "All prerequisites met"
}

# Create Kind cluster
create_cluster() {
    log_info "Creating Kind cluster '$CLUSTER_NAME'..."
    
    # Delete existing cluster if present
    if kind get clusters 2>/dev/null | grep -q "^${CLUSTER_NAME}$"; then
        log_warn "Cluster '$CLUSTER_NAME' already exists, deleting..."
        kind delete cluster --name "$CLUSTER_NAME"
    fi
    
    kind create cluster --name "$CLUSTER_NAME" --config "${REPO_ROOT}/e2e/kind-config.yaml" --wait 60s
    
    log_info "Kind cluster created successfully"
}

# Build and load operator image
build_and_load_image() {
    if [ "$SKIP_BUILD" = true ]; then
        log_info "Skipping image build (--skip-build flag)"
        return
    fi
    
    log_info "Building operator image..."
    
    cd "$REPO_ROOT"
    
    # Build the image using Bazel
    bazel run //cmd:weft_operator_image_load
    
    # Tag for our tests
    docker tag "${IMAGE_NAME}:latest" "${IMAGE_NAME}:${IMAGE_TAG}"
    
    # Load into Kind cluster
    log_info "Loading image into Kind cluster..."
    kind load docker-image "${IMAGE_NAME}:${IMAGE_TAG}" --name "$CLUSTER_NAME"
    
    log_info "Image built and loaded successfully"
}

# Install Helm chart
install_chart() {
    log_info "Installing Helm chart..."
    
    cd "$REPO_ROOT"
    
    # Build and apply CRDs first (they are generated by Bazel, not in the chart directly)
    log_info "Building and applying CRDs..."
    bazel build //api/v1alpha1:generated.crds
    kubectl apply -f bazel-bin/api/v1alpha1/crd.yaml
    
    # Wait for CRDs to be established
    log_info "Waiting for CRDs to be established..."
    for crd in weftservers.weft.aquaduct.dev wefttunnels.weft.aquaduct.dev weftgateways.weft.aquaduct.dev aquaducttaases.weft.aquaduct.dev; do
        kubectl wait --for=condition=established crd/"$crd" --timeout=30s || true
    done
    
    # Install Gateway API CRDs if enabled
    if kubectl get crd gateways.gateway.networking.k8s.io >/dev/null 2>&1; then
        log_info "Gateway API CRDs already installed"
    else
        log_info "Installing Gateway API CRDs..."
        kubectl apply -f chart/templates/crds/gateway-api.yaml
    fi
    
    # Install chart with test image tag
    helm upgrade --install "$RELEASE_NAME" ./chart \
        --namespace "$NAMESPACE" \
        --set image.url="${IMAGE_NAME}:${IMAGE_TAG}" \
        --set image.pullPolicy=Never \
        --set installGatewayCRDs=false \
        --wait \
        --timeout 180s
    
    log_info "Helm chart installed successfully"
}

# Verify CRDs exist
verify_crds() {
    log_test "Verifying CRDs..."
    
    local weft_crds=(
        "weftservers.weft.aquaduct.dev"
        "wefttunnels.weft.aquaduct.dev"
        "weftgateways.weft.aquaduct.dev"
        "aquaducttaases.weft.aquaduct.dev"
    )
    
    local gateway_crds=(
        "gatewayclasses.gateway.networking.k8s.io"
        "gateways.gateway.networking.k8s.io"
        "httproutes.gateway.networking.k8s.io"
    )
    
    log_info "Checking Weft CRDs..."
    for crd in "${weft_crds[@]}"; do
        if kubectl get crd "$crd" >/dev/null 2>&1; then
            log_info "  ✓ $crd"
        else
            log_error "  ✗ $crd not found"
            return 1
        fi
    done
    
    log_info "Checking Gateway API CRDs..."
    for crd in "${gateway_crds[@]}"; do
        if kubectl get crd "$crd" >/dev/null 2>&1; then
            log_info "  ✓ $crd"
        else
            log_warn "  ! $crd not found (optional)"
        fi
    done
    
    log_test "CRD verification passed"
}

# Verify operator deployment
verify_operator() {
    log_test "Verifying operator deployment..."
    
    # Wait for deployment to be ready
    if ! kubectl rollout status deployment/"$RELEASE_NAME" -n "$NAMESPACE" --timeout=60s; then
        log_error "Operator deployment not ready"
        kubectl get pods -n "$NAMESPACE" -l app.kubernetes.io/name=weft-operator
        kubectl describe deployment "$RELEASE_NAME" -n "$NAMESPACE"
        return 1
    fi
    
    # Check pod is running
    local pod_status
    pod_status=$(kubectl get pods -n "$NAMESPACE" -l app.kubernetes.io/name=weft-operator -o jsonpath='{.items[0].status.phase}')
    
    if [ "$pod_status" = "Running" ]; then
        log_info "  ✓ Operator pod is running"
    else
        log_error "  ✗ Operator pod status: $pod_status"
        return 1
    fi
    
    log_test "Operator deployment verified"
}

# Test WeftServer Internal mode
test_weftserver_internal() {
    log_test "Testing WeftServer Internal mode..."
    
    local server_name="e2e-internal-server"
    
    # Create an Internal WeftServer
    cat <<EOF | kubectl apply -f -
apiVersion: weft.aquaduct.dev/v1alpha1
kind: WeftServer
metadata:
  name: ${server_name}
  namespace: $NAMESPACE
spec:
  connectionString: "weft://testsecret@0.0.0.0:9092"
  location: Internal
EOF
    
    log_info "  Created Internal WeftServer"
    
    # Wait for resources to be created
    sleep 5
    
    local dep_name="${server_name}-server"
    local pvc_name="${server_name}-certs"
    
    # Verify Deployment
    if kubectl get deployment "$dep_name" -n "$NAMESPACE" >/dev/null 2>&1; then
        log_info "  ✓ Deployment $dep_name created"
        
        # Check host network
        local host_network
        host_network=$(kubectl get deployment "$dep_name" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.hostNetwork}')
        if [ "$host_network" = "true" ]; then
            log_info "  ✓ Deployment uses host network"
        else
            log_warn "  ! Deployment does not use host network"
        fi
    else
        log_error "  ✗ Deployment not created"
        kubectl delete weftserver "$server_name" -n "$NAMESPACE" --wait=false 2>/dev/null || true
        return 1
    fi
    
    # Verify Service
    if kubectl get service "$dep_name" -n "$NAMESPACE" >/dev/null 2>&1; then
        log_info "  ✓ Service $dep_name created"
    else
        log_error "  ✗ Service not created"
    fi
    
    # Verify PVC
    if kubectl get pvc "$pvc_name" -n "$NAMESPACE" >/dev/null 2>&1; then
        log_info "  ✓ PVC $pvc_name created"
    else
        log_error "  ✗ PVC not created"
    fi
    
    # Cleanup
    kubectl delete weftserver "$server_name" -n "$NAMESPACE" --wait=false
    
    log_test "WeftServer Internal mode test passed"
}

# Test WeftServer External mode
test_weftserver_external() {
    log_test "Testing WeftServer External mode..."
    
    local server_name="e2e-external-server"
    
    # Create an External WeftServer
    cat <<EOF | kubectl apply -f -
apiVersion: weft.aquaduct.dev/v1alpha1
kind: WeftServer
metadata:
  name: ${server_name}
  namespace: $NAMESPACE
spec:
  connectionString: "weft://testsecret@10.0.0.1:8080"
  location: External
EOF
    
    log_info "  Created External WeftServer"
    
    sleep 3
    
    local dep_name="${server_name}-server"
    
    # Verify NO Deployment is created
    if kubectl get deployment "$dep_name" -n "$NAMESPACE" >/dev/null 2>&1; then
        log_error "  ✗ Deployment should NOT be created for External server"
        kubectl delete weftserver "$server_name" -n "$NAMESPACE" --wait=false 2>/dev/null || true
        return 1
    else
        log_info "  ✓ No Deployment created (expected)"
    fi
    
    # Cleanup
    kubectl delete weftserver "$server_name" -n "$NAMESPACE" --wait=false
    
    log_test "WeftServer External mode test passed"
}

# Test WeftTunnel reconciliation
test_wefttunnel() {
    log_test "Testing WeftTunnel reconciliation..."
    
    local server_name="e2e-tunnel-server"
    local tunnel_name="e2e-test-tunnel"
    
    # Create a WeftServer for the tunnel to target
    cat <<EOF | kubectl apply -f -
apiVersion: weft.aquaduct.dev/v1alpha1
kind: WeftServer
metadata:
  name: ${server_name}
  namespace: $NAMESPACE
spec:
  connectionString: "weft://tunneltest@192.168.1.1:8080"
  location: External
EOF
    
    log_info "  Created target WeftServer"
    
    # Create WeftTunnel
    cat <<EOF | kubectl apply -f -
apiVersion: weft.aquaduct.dev/v1alpha1
kind: WeftTunnel
metadata:
  name: ${tunnel_name}
  namespace: $NAMESPACE
spec:
  srcURL: "http://test-service.default.svc.cluster.local:8080"
  dstURL: "https://test.example.com"
  targetServers:
    - ${server_name}
EOF
    
    log_info "  Created WeftTunnel"
    
    sleep 5
    
    local expected_dep="tunnel-${tunnel_name}-to-${server_name}"
    
    # Verify tunnel Deployment is created
    if kubectl get deployment "$expected_dep" -n "$NAMESPACE" >/dev/null 2>&1; then
        log_info "  ✓ Tunnel Deployment $expected_dep created"
        
        # Verify labels
        local app_label
        app_label=$(kubectl get deployment "$expected_dep" -n "$NAMESPACE" -o jsonpath='{.metadata.labels.app}')
        if [ "$app_label" = "weft-tunnel" ]; then
            log_info "  ✓ Deployment has correct app label"
        else
            log_warn "  ! Unexpected app label: $app_label"
        fi
        
        # Verify container args
        local args
        args=$(kubectl get deployment "$expected_dep" -n "$NAMESPACE" -o jsonpath='{.spec.template.spec.containers[0].args[0]}')
        if [ "$args" = "tunnel" ]; then
            log_info "  ✓ Container command is 'tunnel'"
        else
            log_warn "  ! Unexpected first arg: $args"
        fi
    else
        log_error "  ✗ Tunnel Deployment not created"
        kubectl delete wefttunnel "$tunnel_name" -n "$NAMESPACE" --wait=false 2>/dev/null || true
        kubectl delete weftserver "$server_name" -n "$NAMESPACE" --wait=false 2>/dev/null || true
        return 1
    fi
    
    # Verify status conditions
    local conditions
    conditions=$(kubectl get wefttunnel "$tunnel_name" -n "$NAMESPACE" -o jsonpath='{.status.conditions}' 2>/dev/null || echo "")
    if [ -n "$conditions" ] && [ "$conditions" != "null" ]; then
        log_info "  ✓ WeftTunnel has status conditions"
    else
        log_warn "  ! WeftTunnel status conditions not yet populated"
    fi
    
    # Cleanup
    kubectl delete wefttunnel "$tunnel_name" -n "$NAMESPACE" --wait=false
    kubectl delete weftserver "$server_name" -n "$NAMESPACE" --wait=false
    
    log_test "WeftTunnel reconciliation test passed"
}

# Test WeftTunnel cleanup
test_wefttunnel_cleanup() {
    log_test "Testing WeftTunnel cleanup via owner references..."
    
    local server_name="e2e-cleanup-server"
    local tunnel_name="e2e-cleanup-tunnel"
    
    # Create resources
    cat <<EOF | kubectl apply -f -
apiVersion: weft.aquaduct.dev/v1alpha1
kind: WeftServer
metadata:
  name: ${server_name}
  namespace: $NAMESPACE
spec:
  connectionString: "weft://cleanuptest@10.0.0.2:8080"
  location: External
---
apiVersion: weft.aquaduct.dev/v1alpha1
kind: WeftTunnel
metadata:
  name: ${tunnel_name}
  namespace: $NAMESPACE
spec:
  srcURL: "http://cleanup.default.svc.cluster.local:80"
  dstURL: "https://cleanup.example.com"
  targetServers:
    - ${server_name}
EOF
    
    log_info "  Created WeftServer and WeftTunnel"
    
    sleep 5
    
    local expected_dep="tunnel-${tunnel_name}-to-${server_name}"
    
    # Wait for deployment
    if ! kubectl get deployment "$expected_dep" -n "$NAMESPACE" >/dev/null 2>&1; then
        log_error "  ✗ Tunnel Deployment not created"
        kubectl delete wefttunnel "$tunnel_name" -n "$NAMESPACE" --wait=false 2>/dev/null || true
        kubectl delete weftserver "$server_name" -n "$NAMESPACE" --wait=false 2>/dev/null || true
        return 1
    fi
    
    log_info "  ✓ Tunnel Deployment created"
    
    # Delete WeftTunnel
    kubectl delete wefttunnel "$tunnel_name" -n "$NAMESPACE"
    
    log_info "  Deleted WeftTunnel, waiting for cleanup..."
    
    # Wait for deployment to be deleted
    local max_wait=30
    local count=0
    while kubectl get deployment "$expected_dep" -n "$NAMESPACE" >/dev/null 2>&1; do
        if [ $count -ge $max_wait ]; then
            log_error "  ✗ Deployment was not deleted within ${max_wait}s"
            kubectl delete weftserver "$server_name" -n "$NAMESPACE" --wait=false 2>/dev/null || true
            return 1
        fi
        sleep 1
        ((count++))
    done
    
    log_info "  ✓ Deployment deleted via owner reference"
    
    # Cleanup
    kubectl delete weftserver "$server_name" -n "$NAMESPACE" --wait=false
    
    log_test "WeftTunnel cleanup test passed"
}

# Test multi-server tunnel
test_multi_server_tunnel() {
    log_test "Testing multi-server tunnel targeting..."
    
    local server1="e2e-multi-server-1"
    local server2="e2e-multi-server-2"
    local tunnel_name="e2e-multi-tunnel"
    
    # Create two WeftServers
    cat <<EOF | kubectl apply -f -
apiVersion: weft.aquaduct.dev/v1alpha1
kind: WeftServer
metadata:
  name: ${server1}
  namespace: $NAMESPACE
spec:
  connectionString: "weft://multi1@10.0.0.10:8080"
  location: External
---
apiVersion: weft.aquaduct.dev/v1alpha1
kind: WeftServer
metadata:
  name: ${server2}
  namespace: $NAMESPACE
spec:
  connectionString: "weft://multi2@10.0.0.11:8080"
  location: External
EOF
    
    log_info "  Created two WeftServers"
    
    # Create WeftTunnel without targetServers (should target all)
    cat <<EOF | kubectl apply -f -
apiVersion: weft.aquaduct.dev/v1alpha1
kind: WeftTunnel
metadata:
  name: ${tunnel_name}
  namespace: $NAMESPACE
spec:
  srcURL: "http://multi-svc.default.svc.cluster.local:80"
  dstURL: "https://multi.example.com"
EOF
    
    log_info "  Created WeftTunnel without targetServers"
    
    sleep 5
    
    # Verify deployments for both servers
    local dep1="tunnel-${tunnel_name}-to-${server1}"
    local dep2="tunnel-${tunnel_name}-to-${server2}"
    
    for dep in "$dep1" "$dep2"; do
        if kubectl get deployment "$dep" -n "$NAMESPACE" >/dev/null 2>&1; then
            log_info "  ✓ Deployment $dep created"
        else
            log_error "  ✗ Deployment $dep not created"
        fi
    done
    
    # Cleanup
    kubectl delete wefttunnel "$tunnel_name" -n "$NAMESPACE" --wait=false
    kubectl delete weftserver "$server1" -n "$NAMESPACE" --wait=false
    kubectl delete weftserver "$server2" -n "$NAMESPACE" --wait=false
    
    log_test "Multi-server tunnel test passed"
}

# Uninstall Helm chart
uninstall_chart() {
    log_info "Uninstalling Helm chart..."
    
    helm uninstall "$RELEASE_NAME" -n "$NAMESPACE" --wait || true
    
    log_info "Helm chart uninstalled"
}

# Main execution
main() {
    log_info "Starting weft-operator comprehensive integration tests"
    log_info "======================================================="
    
    check_prerequisites
    create_cluster
    build_and_load_image
    install_chart
    
    log_info ""
    log_info "Running verification tests..."
    log_info "-----------------------------"
    
    verify_crds
    verify_operator
    
    log_info ""
    log_info "Running functional tests..."
    log_info "---------------------------"
    
    test_weftserver_external
    test_weftserver_internal
    test_wefttunnel
    test_wefttunnel_cleanup
    test_multi_server_tunnel
    
    log_info ""
    log_info "======================================================="
    log_info "All integration tests passed! ✓"
    log_info "======================================================="
    log_info ""
    log_info "Test Summary:"
    log_info "  - CRD Availability: PASS"
    log_info "  - Operator Deployment: PASS"
    log_info "  - WeftServer External: PASS"
    log_info "  - WeftServer Internal: PASS"
    log_info "  - WeftTunnel Reconciliation: PASS"
    log_info "  - WeftTunnel Cleanup: PASS"
    log_info "  - Multi-Server Tunnel: PASS"
}

main "$@"
